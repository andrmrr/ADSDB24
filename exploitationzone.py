# -*- coding: utf-8 -*-
"""ExploitationZone.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JRNGA0KkGUh7mtke6L9agPJ5ZY4d-5Bc
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install --quiet duckdb-engine
!pip install --quiet pandas

"""# Exploitation zone"""

import duckdb
import pandas as pd
import os
import numpy as np
import re

base_dir = "/content/drive/MyDrive/ADSDB24"
temporal_landing = os.path.join(base_dir,  "landing_zone/temporal")
persistent_landing = os.path.join(base_dir, "landing_zone/persistent")
dataset_folder = "datasets_specific"

# 2017 version
dataset1_fname = "alz_2017.csv"
dataset2_fname = "chr_2017.csv"
# 2021 version
# dataset1_fname = "alz_2021.csv"
# dataset2_fname = "chr_2021.csv"

dataset1 = os.path.join(base_dir, dataset_folder, dataset1_fname)
dataset2 = os.path.join(base_dir, dataset_folder, dataset2_fname)
dataset1_name = "alzheimer"
dataset2_name = "chronic_disease_indicators"
dataset1_abbrev = "alz"
dataset2_abbrev = "chr"

datasets = [
    dataset1, dataset2
]

dataset_names = {
    dataset1_fname: dataset1_name,
    dataset2_fname: dataset2_name
}

dataset_abbrev = {
    dataset1_fname: dataset1_abbrev,
    dataset2_fname: dataset2_abbrev
}

"""DuckDB"""
duckdb_folder = "duckdb_database"
duckdb_formatted = os.path.join(duckdb_folder, "formatted_zone.db")
duckdb_trusted = os.path.join(duckdb_folder, "trusted_zone.db")
duckdb_exploitation = os.path.join(duckdb_folder, "exploitation_zone.db")

"""Metadata"""
metadata_folder = "metadata"
formatted_metadata = "formatted_metadata.json"
alz_metadata_fname = "alzheimer_metadata.json"
chr_metadata_fname = "chronic_disease_indicators_metadata.json"

"""# Separate table by topics (new)"""

con_tru = duckdb.connect(os.path.join(base_dir, duckdb_trusted))
tables = con_tru.execute("SHOW TABLES").fetchall()
for table in tables:
  print(table[0])

alz = con_tru.execute("SELECT * FROM alzheimer").fetchdf()
topcnt = len(alz["Topic"].unique())
print(f"Alzheimer topics: {topcnt}")

chr = con_tru.execute("SELECT * FROM chronic_disease_indicators").fetchdf()
topcnt = len(chr["Topic"].unique())
print(f"Chronic disease indicators topics: {topcnt}")

def filter_topics(table_name, con_tru, con_exp):
  table = con_tru.execute(f"SELECT * FROM {table_name}").fetchdf()
  topics = table["Topic"].unique()

  con_exp.register("temp_table", table)

  for topic in topics:
    # Create name for new table
    topic_table_name = table_name + "_" + topic.lower().replace(" ", "_")
    topic_table_name = re.sub(r'[^a-zA-Z0-9_]', '',topic_table_name)

    # 'alzheimer' table filtered for rows according to val
    command = f"""
        CREATE TABLE {topic_table_name} AS
        SELECT *
        FROM temp_table
        WHERE temp_table.Topic = '{topic}'
    """
    # print(command)
    con_exp.execute(command)
    print(f"Created table {topic_table_name} in exploitation zone.")

"""Create tables for specific categories (Gender)"""

# def filter_genders(con_exp, alz_table, chr_table):
#   # 'alzheimer' table filtered for rows where Gender is female
#   alz_gen_f_table = con_exp.execute(f"""SELECT *
#         FROM alz_table AS a
#         WHERE a.StratificationCategory2 = 'Gender' AND a.Stratification2 = 'Female'
#   """).fetchdf()

#   # 'chronic_diseases' table filtered for rows where Gender is female
#   chr_gen_f_table = con_exp.execute(f"""SELECT *
#         FROM chr_table AS c
#         WHERE c.StratificationCategory1 = 'Gender' AND c.Stratification1 = 'Female'
#   """).fetchdf()

#   con_exp.execute("""CREATE TABLE gender_female AS
#         SELECT a.YearStart, a.YearEnd, a.Datasource AS
#         alz_DataSource, c.DataSource AS chr_DataSource, a.Topic AS alz_Topic,
#         c.Topic AS chr_Topic, a.Question AS alz_Question, c.Question AS chr_Question,
#         c.DataValueUnit AS chr_DataValueUnit,
#         a.Data_Value_Type AS alz_DataValueType, c.DataValueType AS chr_DataValueType,
#         a.Data_Value AS alz_DataValue, c.DataValue AS chr_DataValue,
#         a.Low_Confidence_Limit AS alz_LowConfidenceLimit, c.LowConfidenceLimit AS chr_LowConfidenceLimit,
#         a.High_Confidence_Limit AS alz_HighConfidenceLimit, c.HighConfidenceLimit AS chr_HighConfidenceLimit,
#         a.StratificationCategory1 AS alz_StratificationCategory1,
#         c.StratificationCategory1 AS chr_StratificationCategory1,
#         a.Stratification1 AS alz_Stratification1, c.Stratification1 AS chr_Stratification1
#         FROM alz_gen_f_table a
#         JOIN chr_gen_f_table c
#         ON a.YearStart = c.YearStart
#    """)

#    # 'alzheimer' table filtered for rows where Gender is male
#   alz_gen_m_table = con_exp.execute(f"""SELECT *
#         FROM alz_table AS a
#         WHERE a.StratificationCategory2 = 'Gender' AND a.Stratification2 = 'Male'
#   """).fetchdf()

#   # 'chronic_diseases' table filtered for rows where Gender is male
#   chr_gen_m_table = con_exp.execute(f"""SELECT *
#         FROM chr_table AS c
#         WHERE c.StratificationCategory1 = 'Gender' AND c.Stratification1 = 'Male'
#   """).fetchdf()

#   con_exp.execute("""CREATE TABLE gender_male AS
#         SELECT a.YearStart, a.YearEnd, a.Datasource AS
#         alz_DataSource, c.DataSource AS chr_DataSource, a.Class AS alz_Class, a.Topic AS alz_Topic,
#         c.Topic AS chr_Topic, a.Question AS alz_Question, c.Question AS chr_Question,
#         c.DataValueUnit AS chr_DataValueUnit,
#         a.Data_Value_Type AS alz_DataValueType, c.DataValueType AS chr_DataValueType,
#         a.Data_Value AS alz_DataValue, c.DataValue AS chr_DataValue,
#         a.Low_Confidence_Limit AS alz_LowConfidenceLimit, c.LowConfidenceLimit AS chr_LowConfidenceLimit,
#         a.High_Confidence_Limit AS alz_HighConfidenceLimit, c.HighConfidenceLimit AS chr_HighConfidenceLimit,
#         a.StratificationCategory1 AS alz_StratificationCategory1,
#         c.StratificationCategory1 AS chr_StratificationCategory1,
#         a.Stratification1 AS alz_Stratification1, c.Stratification1 AS chr_Stratification1
#         FROM alz_gen_m_table a
#         JOIN chr_gen_m_table c
#         ON a.YearStart = c.YearStart
#    """)

"""
Reconciliation of Stratification values for Ethinicity/Race aggregation"""

# def alz_chr_reconciliation(alz_table, chr_table):
#       def mapping(s):
#             if s == 'Asian/Pacific Islander' or s == 'Asian or Pacific Islander':
#                   return 'Asian_or_Pacific_Islander'
#             elif s == 'Native Am/Alaskan Native' or s == 'American Indian or Alaska Native':
#                   return 'American_Indian_or_Alaska_Native'
#             elif s == 'White, non-Hispanic':
#                   return 'White'
#             elif s == 'Black, non-Hispanic':
#                   return 'Black'
#             elif s == 'Asian, non-Hispanic':
#                   return 'Asian_or_Pacific_Islander'
#             else:
#                   return "Other"

#       str_alz = alz_table['Stratification2'].astype(str)
#       str_chr = chr_table['Stratification1'].astype(str)
#       alz_table['Standardized_Race_Strat'] = str_alz.map(mapping)
#       chr_table['Standardized_Race_Strat'] = str_chr.map(mapping)
#       return alz_table, chr_table

"""Create tables for specific categories (Race/Ethnicity)"""

# def filter_race(con_exp, alz_table, chr_table):
#   # Standardize values in Stratification columns
#   alz_table, chr_table = alz_chr_reconciliation(alz_table, chr_table)

#   # Get unique values for Stratification in both tables
#   str_alz = alz_table['Standardized_Race_Strat'].astype(str)
#   str_chr = chr_table['Standardized_Race_Strat'].astype(str)
#   unique_alz = str_alz.unique()
#   unique_chr = str_chr.unique()

#   # Check same unique values for both tables to join them, remove values "Male" and "Female"
#   same_unq_values = np.intersect1d(unique_alz, unique_chr)
#   filtered_unq_values = [val for val in same_unq_values if val not in ['Female', 'Male']]

#   for val in filtered_unq_values:
#     # Create name for new joined table
#     joined_table_name = f"joined_{val}_table"

#     # 'alzheimer' table filtered for rows according to val
#     alz_rac_table = con_exp.execute(f"""
#         SELECT *
#         FROM alz_table AS a
#         WHERE a.StratificationCategory2 = 'Race/Ethnicity' AND a.Standardized_Race_Strat = '{val}'
#     """).fetchdf()

#     # 'chronic_diseases' table filtered for rows according to val
#     chr_rac_table = con_exp.execute(f"""
#         SELECT *
#         FROM chr_table AS c
#         WHERE c.StratificationCategory1 = 'Race/Ethnicity' AND c.Standardized_Race_Strat = '{val}'
#     """).fetchdf()

#     # Join tables with same Race/Ethnicity
#     join_q = f"""CREATE TABLE {joined_table_name} AS
#         SELECT a.YearStart, a.YearEnd, a.Datasource AS
#         alz_DataSource, c.DataSource AS chr_DataSource, a.Class AS alz_Class, a.Topic AS alz_Topic,
#         c.Topic AS chr_Topic, a.Question AS alz_Question, c.Question AS chr_Question,
#         c.DataValueUnit AS chr_DataValueUnit,
#         a.Data_Value_Type AS alz_DataValueType, c.DataValueType AS chr_DataValueType,
#         a.Data_Value AS alz_DataValue, c.DataValue AS chr_DataValue,
#         a.Low_Confidence_Limit AS alz_LowConfidenceLimit, c.LowConfidenceLimit AS chr_LowConfidenceLimit,
#         a.High_Confidence_Limit AS alz_HighConfidenceLimit, c.HighConfidenceLimit AS chr_HighConfidenceLimit,
#         a.StratificationCategory1 AS alz_StratificationCategory1,
#         c.StratificationCategory1 AS chr_StratificationCategory1,
#         a.Stratification1 AS alz_Stratification1, c.Stratification1 AS chr_Stratification1,
#         a.Standardized_Race_Strat AS alz_Standardized_Race_Strat,
#         c.Standardized_Race_Strat AS chr_Standardized_Race_Strat
#         FROM alz_rac_table a
#         JOIN chr_rac_table c
#         ON a.YearStart = c.YearStart
#     """
#     con_exp.execute(join_q)

"""Old main"""

# # Load dataframes from trusted zone
# con_tru = duckdb.connect(os.path.join(base_dir, duckdb_trusted))
# alz_table = con_tru.execute(f"SELECT * FROM {dataset1_name}").fetchdf()
# chr_table = con_tru.execute(f"SELECT * FROM {dataset2_name}").fetchdf()
# con_tru.close()

# # Filter dataframes for specific categories
# con_exp = duckdb.connect(os.path.join(base_dir, duckdb_exploitation))

# # Empty the database first
# tables = con_exp.execute("SHOW TABLES").fetchall()
# tables = [table[0] for table in tables]
# for table in tables:
#     con_exp.execute(f"DROP TABLE {table}")

# # Execute propagation
# filter_genders(con_exp, alz_table, chr_table)
# filter_race(con_exp, alz_table, chr_table)

# con_exp.close()

"""Main for Exploitation Zone"""

con_tru = duckdb.connect(os.path.join(base_dir, duckdb_trusted))
con_exp = duckdb.connect(os.path.join(base_dir, duckdb_exploitation))

# Empty the database first
tables = con_exp.execute("SHOW TABLES").fetchall()
tables = [table[0] for table in tables]
for table in tables:
    con_exp.execute(f"DROP TABLE {table}")

# Filter topics
for table_fname, table_name in dataset_names.items():
  filter_topics(table_name, con_tru, con_exp)

con_tru.close()
con_exp.close()

"""## For testing"""

# con_exp = duckdb.connect(os.path.join(base_dir, duckdb_exploitation))
# tables = con_exp.execute("SHOW TABLES").fetchall()
# for table in tables:
#   print(table[0])
#   if table[0] == "chronic_disease_indicators_asthma":
#     df = con_exp.execute("SELECT * FROM chronic_disease_indicators_asthma").fetchdf()
#     print(df.columns)
# con_exp.close()