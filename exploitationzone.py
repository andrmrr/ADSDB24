# -*- coding: utf-8 -*-
"""ExploitationZone.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JRNGA0KkGUh7mtke6L9agPJ5ZY4d-5Bc
"""

from google.colab import drive
drive.mount('/content/drive')

"""# Exploitation zone"""

import duckdb
import pandas as pd
import time
import os
import numpy as np

base_dir = "/content/drive/MyDrive/ADSDB24"
temporal_landing = os.path.join(base_dir,  "landing_zone/temporal")
persistent_landing = os.path.join(base_dir, "landing_zone/persistent")
duckdb_db = os.path.join(base_dir, "duckdb_database", "formatted_zone.db")

alzheimer_folder = os.path.join(base_dir, "landing_zone/persistent/alzheimer")
chronic_folder = os.path.join(base_dir, "landing_zone/persistent/chronic_disease_indicators")

datasource1 = os.path.join(base_dir, "datasets_original/Alzheimer_s_Disease_and_Healthy_Aging_Data.csv")
datasource1_name = "alzheimer"
datasource2 = os.path.join(base_dir, "datasets_original/U.S._Chronic_Disease_Indicators__CDI___2023_Release.csv")
datasource2_name = "chronic_disease_indicators"

"""Create new database for exploitation zone"""

def create_db_exp_zone():
  # File path for new database
  duckdb_expzone = os.path.join(base_dir, "duckdb_database/exploitation_zone.db")

  # Connect new database and create it
  con = duckdb.connect(duckdb_expzone)

  # Initialize the database by creating dummy table
  con.execute("CREATE TABLE sample_table (id INTEGER, name VARCHAR)")

  con.close()

"""Integrate tables from trusted zone into 1 table"""

def integrate_to_exp(con_exp, con_for):
  # Getting 'alzheimer' and 'chronic_disease'
  alz_table = con_for.execute("SELECT * FROM alzheimer").fetchdf()
  chr_table = con_for.execute("SELECT * FROM chronic_diseases").fetchdf()

  # Join them into one by column 'year'
  # Change names of columns which have the same name
  # Get rid of duplicate columns (same values for every row in both tables)
  # join_query = """SELECT DISTINCT a.YearStart, a.YearEnd, a.LocationAbbr, a.LocationDesc,
  #       FROM alz_table a
  #       JOIN chr_table c
  #       ON a.YearStart = c.YearStart
  # """

  # New joined table and show the head
  # joined_table = con_exp.execute(join_query).fetchdf()
  # print(joined_table.head())

  con_for.close()

  return alz_table, chr_table

"""Create tables for specific categories (Gender)"""

# Table with information only for Stratification: Gender - female and male separately
def filter_genders(con_exp, alz_table, chr_table):
  # 'alzheimer' table filtered for rows where Gender is female
  alz_gen_f_table = con_exp.execute(f"""SELECT *
        FROM alz_table AS a
        WHERE a.StratificationCategory2 = 'Gender' AND a.Stratification2 = 'Female'
  """).fetchdf()

  # 'chronic_diseases' table filtered for rows where Gender is female
  chr_gen_f_table = con_exp.execute(f"""SELECT *
        FROM chr_table AS c
        WHERE c.StratificationCategory1 = 'Gender' AND c.Stratification1 = 'Female'
  """).fetchdf()

  con_exp.register('alz_gen_f_table', alz_gen_f_table)
  con_exp.register('chr_gen_f_table', chr_gen_f_table)

  join_gen_f = con_exp.execute("""CREATE TABLE gender_female AS
        SELECT a.YearStart, a.YearEnd, a.LocationAbbr, a.LocationDesc, a.Datasource AS
        alz_DataSource, c.DataSource AS chr_DataSource, a.Topic AS alz_Topic,
        c.Topic AS chr_Topic, a.Question AS alz_Question, c.Question AS chr_Question,
        a.Data_Value_Unit AS alz_DataValueUnit, c.DataValueUnit AS chr_DataValueUnit,
        a.Data_Value_Type AS alz_DataValueType, c.DataValueType AS chr_DataValueType,
        a.Data_Value AS alz_DataValue, c.DataValue AS chr_DataValue,
        a.Data_Value_Alt AS alz_DataValueAlt, c.DataValueAlt AS chr_DataValueAlt,
        a.Low_Confidence_Limit AS alz_LowConfidenceLimit, c.LowConfidenceLimit AS chr_LowConfidenceLimit,
        a.High_Confidence_Limit AS alz_HighConfidenceLimit, c.HighConfidenceLimit AS chr_HighConfidenceLimit,
        a.StratificationCategory1 AS alz_StratificationCategory1,
        c.StratificationCategory1 AS chr_StratificationCategory1,
        a.Stratification1 AS alz_Stratification1, c.Stratification1 AS chr_Stratification1,
        a.Geolocation AS alz_GeoLocation, c.GeoLocation AS chr_GeoLocation
        FROM alz_gen_f_table a
        JOIN chr_gen_f_table c
        ON a.YearStart = c.YearStart
   """).fetchdf()

   # 'alzheimer' table filtered for rows where Gender is male
  alz_gen_m_table = con_exp.execute(f"""SELECT *
        FROM alz_table AS a
        WHERE a.StratificationCategory2 = 'Gender' AND a.Stratification2 = 'Male'
  """).fetchdf()

  # 'chronic_diseases' table filtered for rows where Gender is male
  chr_gen_m_table = con_exp.execute(f"""SELECT *
        FROM chr_table AS c
        WHERE c.StratificationCategory1 = 'Gender' AND c.Stratification1 = 'Male'
  """).fetchdf()

  con_exp.register('alz_gen_m_table', alz_gen_m_table)
  con_exp.register('chr_gen_m_table', chr_gen_m_table)

  join_gen_m = con_exp.execute("""CREATE TABLE gender_male AS
        SELECT a.YearStart, a.YearEnd, a.LocationAbbr, a.LocationDesc, a.Datasource AS
        alz_DataSource, c.DataSource AS chr_DataSource, a.Topic AS alz_Topic,
        c.Topic AS chr_Topic, a.Question AS alz_Question, c.Question AS chr_Question,
        a.Data_Value_Unit AS alz_DataValueUnit, c.DataValueUnit AS chr_DataValueUnit,
        a.Data_Value_Type AS alz_DataValueType, c.DataValueType AS chr_DataValueType,
        a.Data_Value AS alz_DataValue, c.DataValue AS chr_DataValue,
        a.Data_Value_Alt AS alz_DataValueAlt, c.DataValueAlt AS chr_DataValueAlt,
        a.Low_Confidence_Limit AS alz_LowConfidenceLimit, c.LowConfidenceLimit AS chr_LowConfidenceLimit,
        a.High_Confidence_Limit AS alz_HighConfidenceLimit, c.HighConfidenceLimit AS chr_HighConfidenceLimit,
        a.StratificationCategory1 AS alz_StratificationCategory1,
        c.StratificationCategory1 AS chr_StratificationCategory1,
        a.Stratification1 AS alz_Stratification1, c.Stratification1 AS chr_Stratification1,
        a.Geolocation AS alz_GeoLocation, c.GeoLocation AS chr_GeoLocation
        FROM alz_gen_m_table a
        JOIN chr_gen_m_table c
        ON a.YearStart = c.YearStart
   """).fetchdf()

"""Create tables for specific categories (Race/Ethnicity)"""

# Table with information only for Stratification: Race/Ethnicity
def filter_race(con_exp, alz_table, chr_table):
  # Get unique values for Stratification in both tables
  str_alz = alz_table['Stratification2'].astype(str)
  str_chr = chr_table['Stratification1'].astype(str)
  unique_alz = str_alz.unique()
  unique_chr = str_chr.unique()

  # Check same unique values for both tables to join them
  same_unq_values = np.intersect1d(unique_alz, unique_chr)
  filtered_unq_values = [val for val in same_unq_values if val not in ['Female', 'Male']]
  final_values = [val.split(',')[0].split()[0] for val in filtered_unq_values]

  for val in final_values:
    # Create name for new joined table
    joined_table_name = f"joined_{val}_table"

    # 'alzheimer' table filtered for rows according to val
    alz_rac_table = con_exp.execute(f"""
        SELECT *
        FROM alz_table AS a
        WHERE a.StratificationCategory2 = 'Race/Ethnicity' AND a.Stratification2 = '{val}'
    """).fetchdf()

    # 'chronic_diseases' table filtered for rows according to val
    chr_rac_table = con_exp.execute(f"""
        SELECT *
        FROM chr_table AS c
        WHERE c.StratificationCategory1 = 'Race/Ethnicity' AND c.Stratification1 = '{val}'
    """).fetchdf()

    # Make sure the table names are temporarily in the database
    con_exp.register('alz_rac_table', alz_rac_table)
    con_exp.register('chr_rac_table', chr_rac_table)

    # Join tables with same Race/Ethnicity
    join_q = f"""CREATE TABLE {joined_table_name} AS
        SELECT a.YearStart, a.YearEnd, a.LocationAbbr, a.LocationDesc, a.Datasource AS
        alz_DataSource, c.DataSource AS chr_DataSource, a.Topic AS alz_Topic,
        c.Topic AS chr_Topic, a.Question AS alz_Question, c.Question AS chr_Question,
        a.Data_Value_Unit AS alz_DataValueUnit, c.DataValueUnit AS chr_DataValueUnit,
        a.Data_Value_Type AS alz_DataValueType, c.DataValueType AS chr_DataValueType,
        a.Data_Value AS alz_DataValue, c.DataValue AS chr_DataValue,
        a.Data_Value_Alt AS alz_DataValueAlt, c.DataValueAlt AS chr_DataValueAlt,
        a.Low_Confidence_Limit AS alz_LowConfidenceLimit, c.LowConfidenceLimit AS chr_LowConfidenceLimit,
        a.High_Confidence_Limit AS alz_HighConfidenceLimit, c.HighConfidenceLimit AS chr_HighConfidenceLimit,
        a.StratificationCategory1 AS alz_StratificationCategory1,
        c.StratificationCategory1 AS chr_StratificationCategory1,
        a.Stratification1 AS alz_Stratification1, c.Stratification1 AS chr_Stratification1,
        a.Geolocation AS alz_GeoLocation, c.GeoLocation AS chr_GeoLocation
        FROM alz_rac_table a
        JOIN chr_rac_table c
        ON a.YearStart = c.YearStart
    """
    con_exp.execute(join_q)
    joined_table = con_exp.execute(f"SELECT * FROM {joined_table_name}").fetchdf()

  # Show all tables using the 'SHOW TABLES' command
  tables = con_exp.execute("SHOW TABLES").fetchall()
  print("Tables in the database:")
  for table in tables:
    print(table[0])

"""Main for Exploitation Zone"""

#create_db_exp_zone()

# File path for new database in exploitation zone
duckdb_expzone = os.path.join(base_dir, "duckdb_database/exploitation_zone.db")
duckdb_truzone = os.path.join(base_dir, "duckdb_database/trusted_zone.db")

con_tru = duckdb.connect(duckdb_truzone)
con_exp = duckdb.connect(duckdb_expzone)

alz_table, chr_table = integrate_to_exp(con_exp, con_tru)

filter_genders(con_exp, alz_table, chr_table)
#filter_race(con_exp, alz_table, chr_table)

con_exp.close()

# Drop the table named 'joined_table'
con_exp.execute("DROP TABLE IF EXISTS joined_table")

# Show all tables using the 'SHOW TABLES' command
tables = con_exp.execute("SHOW TABLES").fetchall()
print("Tables in the database:")
for table in tables:
    print(table[0])