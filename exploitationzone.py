"""
Exploitation zone

"""

import duckdb
import pandas as pd
import os
import numpy as np

from util import *

"""Create tables for specific categories (Gender)"""

# Table with information only for Stratification: Gender - female and male separately
def filter_genders(con_exp, alz_table, chr_table):
  # 'alzheimer' table filtered for rows where Gender is female
  alz_gen_f_table = con_exp.execute(f"""SELECT *
        FROM alz_table AS a
        WHERE a.StratificationCategory2 = 'Gender' AND a.Stratification2 = 'Female'
  """).fetchdf()

  # 'chronic_diseases' table filtered for rows where Gender is female
  chr_gen_f_table = con_exp.execute(f"""SELECT *
        FROM chr_table AS c
        WHERE c.StratificationCategory1 = 'Gender' AND c.Stratification1 = 'Female'
  """).fetchdf()

  con_exp.execute("""CREATE TABLE gender_female AS
        SELECT a.YearStart, a.YearEnd, a.Datasource AS
        alz_DataSource, c.DataSource AS chr_DataSource, a.Topic AS alz_Topic,
        c.Topic AS chr_Topic, a.Question AS alz_Question, c.Question AS chr_Question,
        c.DataValueUnit AS chr_DataValueUnit,
        a.Data_Value_Type AS alz_DataValueType, c.DataValueType AS chr_DataValueType,
        a.Data_Value AS alz_DataValue, c.DataValue AS chr_DataValue,
        a.Low_Confidence_Limit AS alz_LowConfidenceLimit, c.LowConfidenceLimit AS chr_LowConfidenceLimit,
        a.High_Confidence_Limit AS alz_HighConfidenceLimit, c.HighConfidenceLimit AS chr_HighConfidenceLimit,
        a.StratificationCategory1 AS alz_StratificationCategory1,
        c.StratificationCategory1 AS chr_StratificationCategory1,
        a.Stratification1 AS alz_Stratification1, c.Stratification1 AS chr_Stratification1
        FROM alz_gen_f_table a
        JOIN chr_gen_f_table c
        ON a.YearStart = c.YearStart
   """)

   # 'alzheimer' table filtered for rows where Gender is male
  alz_gen_m_table = con_exp.execute(f"""SELECT *
        FROM alz_table AS a
        WHERE a.StratificationCategory2 = 'Gender' AND a.Stratification2 = 'Male'
  """).fetchdf()

  # 'chronic_diseases' table filtered for rows where Gender is male
  chr_gen_m_table = con_exp.execute(f"""SELECT *
        FROM chr_table AS c
        WHERE c.StratificationCategory1 = 'Gender' AND c.Stratification1 = 'Male'
  """).fetchdf()

  con_exp.execute("""CREATE TABLE gender_male AS
        SELECT a.YearStart, a.YearEnd, a.Datasource AS
        alz_DataSource, c.DataSource AS chr_DataSource, a.Class AS alz_Class, a.Topic AS alz_Topic,
        c.Topic AS chr_Topic, a.Question AS alz_Question, c.Question AS chr_Question,
        c.DataValueUnit AS chr_DataValueUnit,
        a.Data_Value_Type AS alz_DataValueType, c.DataValueType AS chr_DataValueType,
        a.Data_Value AS alz_DataValue, c.DataValue AS chr_DataValue,
        a.Low_Confidence_Limit AS alz_LowConfidenceLimit, c.LowConfidenceLimit AS chr_LowConfidenceLimit,
        a.High_Confidence_Limit AS alz_HighConfidenceLimit, c.HighConfidenceLimit AS chr_HighConfidenceLimit,
        a.StratificationCategory1 AS alz_StratificationCategory1,
        c.StratificationCategory1 AS chr_StratificationCategory1,
        a.Stratification1 AS alz_Stratification1, c.Stratification1 AS chr_Stratification1
        FROM alz_gen_m_table a
        JOIN chr_gen_m_table c
        ON a.YearStart = c.YearStart
   """)


def alz_chr_reconciliation(alz_table, chr_table):
      def mapping(s):
            if s == 'Asian/Pacific Islander' or s == 'Asian or Pacific Islander':
                  return 'Asian_or_Pacific_Islander'
            elif s == 'Native Am/Alaskan Native' or s == 'American Indian or Alaska Native':
                  return 'American_Indian_or_Alaska_Native'
            elif s == 'White, non-Hispanic':
                  return 'White'
            elif s == 'Black, non-Hispanic':
                  return 'Black'
            elif s == 'Asian, non-Hispanic':
                  return 'Asian_or_Pacific_Islander'
            else:
                  return "Other"

      str_alz = alz_table['Stratification2'].astype(str)
      str_chr = chr_table['Stratification1'].astype(str)
      alz_table['Standardized_Race_Strat'] = str_alz.map(mapping)
      chr_table['Standardized_Race_Strat'] = str_chr.map(mapping)
      return alz_table, chr_table
      
"""Create tables for specific categories (Race/Ethnicity)"""

# Table with information only for Stratification: Race/Ethnicity
def filter_race(con_exp, alz_table, chr_table):
  # Standardize values in Stratification columns
  alz_table, chr_table = alz_chr_reconciliation(alz_table, chr_table)

  # Get unique values for Stratification in both tables
  str_alz = alz_table['Standardized_Race_Strat'].astype(str)
  str_chr = chr_table['Standardized_Race_Strat'].astype(str)
  unique_alz = str_alz.unique()
  unique_chr = str_chr.unique()

  # Check same unique values for both tables to join them, remove values "Male" and "Female"
  same_unq_values = np.intersect1d(unique_alz, unique_chr)
  filtered_unq_values = [val for val in same_unq_values if val not in ['Female', 'Male']]

  for val in filtered_unq_values:
    # Create name for new joined table
    joined_table_name = f"joined_{val}_table"

    # 'alzheimer' table filtered for rows according to val
    alz_rac_table = con_exp.execute(f"""
        SELECT *
        FROM alz_table AS a
        WHERE a.StratificationCategory2 = 'Race/Ethnicity' AND a.Standardized_Race_Strat = '{val}'
    """).fetchdf()

    # 'chronic_diseases' table filtered for rows according to val
    chr_rac_table = con_exp.execute(f"""
        SELECT *
        FROM chr_table AS c
        WHERE c.StratificationCategory1 = 'Race/Ethnicity' AND c.Standardized_Race_Strat = '{val}'
    """).fetchdf()

    # Join tables with same Race/Ethnicity
    join_q = f"""CREATE TABLE {joined_table_name} AS
        SELECT a.YearStart, a.YearEnd, a.Datasource AS
        alz_DataSource, c.DataSource AS chr_DataSource, a.Class AS alz_Class, a.Topic AS alz_Topic,
        c.Topic AS chr_Topic, a.Question AS alz_Question, c.Question AS chr_Question,
        c.DataValueUnit AS chr_DataValueUnit,
        a.Data_Value_Type AS alz_DataValueType, c.DataValueType AS chr_DataValueType,
        a.Data_Value AS alz_DataValue, c.DataValue AS chr_DataValue,
        a.Low_Confidence_Limit AS alz_LowConfidenceLimit, c.LowConfidenceLimit AS chr_LowConfidenceLimit,
        a.High_Confidence_Limit AS alz_HighConfidenceLimit, c.HighConfidenceLimit AS chr_HighConfidenceLimit,
        a.StratificationCategory1 AS alz_StratificationCategory1,
        c.StratificationCategory1 AS chr_StratificationCategory1,
        a.Stratification1 AS alz_Stratification1, c.Stratification1 AS chr_Stratification1,
        a.Standardized_Race_Strat AS alz_Standardized_Race_Strat, 
        c.Standardized_Race_Strat AS chr_Standardized_Race_Strat
        FROM alz_rac_table a
        JOIN chr_rac_table c
        ON a.YearStart = c.YearStart
    """
    con_exp.execute(join_q)

  
"""Main for Exploitation Zone"""
def load_to_exploitation():
  # Load dataframes from trusted zone
  con_tru = duckdb.connect(duckdb_trusted)
  alz_table = con_tru.execute(f"SELECT * FROM {dataset1_name}").fetchdf()
  chr_table = con_tru.execute(f"SELECT * FROM {dataset2_name}").fetchdf()
  con_tru.close()

  # Filter dataframes for specific categories
  con_exp = duckdb.connect(duckdb_exploitation)
  
  # empty the database first
  tables = con_exp.execute("SHOW TABLES").fetchall()
  tables = [table[0] for table in tables]
  for table in tables:
      con_exp.execute(f"DROP TABLE {table}")

  filter_genders(con_exp, alz_table, chr_table)
  filter_race(con_exp, alz_table, chr_table)
  con_exp.close()